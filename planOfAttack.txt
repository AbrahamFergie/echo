// vim: ft=javascript

// server/services/survey

// (subjectId, statId) => [
//   {respondentId, value, at, statId},
//   ...
// ]

const projectReviews = [
  {
    player: {
      id,
      stats {
        PROJECT_REVIEW_EXPERIENCE,
        PROJECT_REVIEW_ACCURACY,
        PROJECT_EXTERNAL_REVIEW_COUNT,
        PROJECT_INTERNAL_REVIEW_COUNT,
      },
    },
    internal, // Boolean
    responses: {
      PROJECT_QUALITY,
      PROJECT_COMPLETENESS,
    }
    submittedAt,
  }
]
// pure function. takes a project and projectReviews with embedded
// players and their stats.
function calculateProjectReviewStats(project, projectReviews) {
  return {PROJECT_QUALITY, PROJECT_COMPLETENESS}
}

const projectReviewInfo = [
  {
    project,
    projectReviews, // see above
  }
]
// pure function. takes a player and an array of details about each project
// that player submited a review for (extra projects will be ignored).
function calculateProjectReviewStatsForPlayer(player, projectReviewInfo) {
  // body
  return {
    PROJECT_REVIEW_EXPERIENCE,
    PROJECT_REVIEW_ACCURACY,
    PROJECT_EXTERNAL_REVIEW_COUNT,
    PROJECT_INTERNAL_REVIEW_COUNT,
  }
}

async function closeProject(project) {
  await Progect.get(project.id).update({
    state: PROJECT_STATES.CLOSED_FOR_REVIEW
  })
  const projectReviews = await getProjectReviews(project.id)
  const projectStats = calculateProjectStats(project, projectReviews)
  await Progect.get(project.id).update(_ => ({
    stats: _('stats').merge(projectStats),
    state: PROJECT_STATES.CLOSED,
  }))
}

function projectStateCheckCron() {
  const projects = await Project.filter({state: REVIEW})
  const projectsToClose = projects
    .map(_ => )
    .filter(project => {
      const reviews = getProjectReviews(project.id)
      const lastReviewedAt = Math.max(reviews.map(_ => _.submittedAt))
      const externalReviews = reviews.filter(review => !review.internal)
      return externalReviews > 0 && lastReviewedAt < 5daysAgo
    })
  projectsToClose.forEach(submitProjectCloseJob)

  const projectsToAbandon = projects
    .map(_ => )
    .filter(project => {
      const reviews = getProjectReviews(project.id)
      const lastReviewedAt = Math.max(reviews.map(_ => _.submittedAt))
      const externalReviews = reviews.filter(review => !review.internal)
      return externalReviews === 0 && lastReviewedAt < 20daysAgo
    })

  Promise.each(projectsToAbandon, project =>
    Project.get(project.id).update({
      state: PROJECT_STATES.CLOSED_FOR_REVIEW
    })
  )
}

// Potential race condition:
//
// 1. Job 1 - Close Project A with players 1, 2, 3
// 2. Job 1 - recalculates RXP for player 1
// 3. Job 1 - recalculates RXP for player 2
// 4. Job 2 - Closes project B with players 2, 3 using new RXP for player 2, but old RXP for player 3
// 5. Job 2 - recalculates RXP for player 1
// 6. Job 2 - recalculates RXP for player 2
// 7. Job 2 - recalculates RXP for player 3
// 8. Job 1 - recalculates RXP for player 3
//
// Players 1 & 2 had their RXP updated from project A, then B
// Player 3 had their RXP updated for project B, then A
// Project B chose a top reviewer based on the post-A stats for players 1 and 2, but the pre-A stats for player 3
//
// Solution:
// Make sure only one project is being closed at a time. Use a queue with only one worker processing results.


// Changes to Project Model

const PROJECT_STATES = {
  IN_PROGRESS      , // work in progress, no external reviews allowed.
  REVIEW           , // project work complete, open for external reviews (triggered by first internal review, ei. the retro)
  CLOSED_FOR_REVIEW, // no more reviews, final calculateProjectStats in progress
  CLOSED           , // final calculateProjectStats complete
  ABANDONED        , // 20 days passed with no external reviews, unable to calculate project stats
}

const project = {
  ...oldProjectModel,
  state, // one of PROJECT_STATES
  closedAt, // when the project was closed
}

// Changes to Player Model
const player = {
  ...oldPlayerModel,
  stats: { ...oldPlayerModel.stats,
    PROJECT_REVIEW_EXPERIENCE,
    PROJECT_REVIEW_ACCURACY,
    INTERNAL_PROJECT_REVIEW_COUNT,
    EXTERNAL_PROJECT_REVIEW_COUNT,
  },
  // Seeds used to give a player a non-zero starting point for stats caluclations
  // used to repace the hard-coded ids in the stats script for SEPs and to give all
  // players a starting point for REVIEW_ACCRACY (ELO/100)
  statSeeds: {
    PROJECT_REVIEW_EXPERIENCE,
    PROJECT_REVIEW_ACCURACY,
    INTERNAL_PROJECT_REVIEW_COUNT,
    EXTERNAL_PROJECT_REVIEW_COUNT,
    ELO_RANKING,
    EXPERIENCE_POINTS,
  }
}

// CHORES:
// 1. stat seeds
// 2. run stats doesn't blow away ALL stats (have each server action blow away the relevant stats?)
//


// POSSIBLE REFACTORING
// Move project stats out into their own table?
